<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>plugin-architecture on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/plugin-architecture/</link>
    <description>Recent content in plugin-architecture on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2019 - 2026 Gunnar Morling</copyright>
    <lastBuildDate>Wed, 14 Oct 2020 17:45:00 +0200</lastBuildDate>
    <atom:link href="https://www.morling.dev/tags/plugin-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Class Unloading in Layered Java Applications</title>
      <link>https://www.morling.dev/blog/class-unloading-in-layered-java-applications/</link>
      <pubDate>Wed, 14 Oct 2020 17:45:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/class-unloading-in-layered-java-applications/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_do_we_really_need_plug_ins&#34;&gt;Do We Really Need Plug-ins?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_plug_ins_in_layered_java_applications&#34;&gt;Plug-ins in Layered Java Applications&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_class_unloading_in_practice&#34;&gt;Class Unloading in Practice&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_if_things_go_wrong&#34;&gt;If Things Go Wrong&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_learning_more&#34;&gt;Learning More&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Layers are sort of the secret sauce of the Java platform module system (JPMS):&#xA;by providing fine-grained control over how individual JPMS modules and their classes are loaded by the JVM,&#xA;they enable advanced usages like loading multiple versions of a given module, or dynamically adding and removing modules at application runtime.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://www.morling.dev/blog/introducing-layrry-runner-and-api-for-modularized-java-applications/&#34;&gt;Layrry&lt;/a&gt; API and launcher provides a small plug-in API based on top of layers,&#xA;which for instance can be used to dynamically add plug-ins contributing new views and widgets to a running JavaFX application.&#xA;If such plug-in gets removed from the application again,&#xA;all its classes need to be unloaded by the JVM, avoiding an ever-increasing memory consumption if for instance a plug-in gets updated multiple times.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In this blog post I’m going to explore how to ensure classes from removed plug-in layers are unloaded in a timely manner,&#xA;and how to find the culprit in case some class fails to be unloaded.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Plug-in Architectures With Layrry and the Java Module System</title>
      <link>https://www.morling.dev/blog/plugin-architectures-with-layrry-and-the-java-module-system/</link>
      <pubDate>Tue, 21 Apr 2020 18:54:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/plugin-architectures-with-layrry-and-the-java-module-system/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_an_example_the_greeter_cli_app&#34;&gt;An Example: The Greeter CLI App&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_application_plug_ins_with_layrry&#34;&gt;Application Plug-ins With Layrry&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_finding_plug_in_implementations_with_the_java_service_loader&#34;&gt;Finding Plug-in Implementations With the Java Service Loader&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_seeing_it_in_action&#34;&gt;Seeing it in Action&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Making applications extensible with some form of plug-ins is a very common pattern in software design:&#xA;based on well-defined APIs provided by the application core, plug-ins can customize an application’s behavior and provide new functionality.&#xA;Examples include desktop applications like IDEs or web browsers, build tools such as Apache Maven or Gradle, as well as server-side applications such as Apache Kafka Connect,&#xA;a runtime for Kafka connectors plug-ins.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In this post I’m going to explore how the &lt;a href=&#34;https://www.jcp.org/en/jsr/detail?id=376&#34;&gt;Java Platform Module System&lt;/a&gt;&amp;#39;s notion of module layers can be leveraged for implementing plug-in architectures on the JVM.&#xA;We’ll also discuss how &lt;a href=&#34;https://github.com/moditect/layrry&#34;&gt;Layrry&lt;/a&gt;, a launcher and runtime for layered Java applications, can help with this task.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Introducing Layrry: A Launcher and API for Modularized Java Applications</title>
      <link>https://www.morling.dev/blog/introducing-layrry-runner-and-api-for-modularized-java-applications/</link>
      <pubDate>Sun, 29 Mar 2020 21:31:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/introducing-layrry-runner-and-api-for-modularized-java-applications/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_why_layrry&#34;&gt;Why Layrry?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_an_example&#34;&gt;An Example&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_module_layers_to_the_rescue&#34;&gt;Module Layers to the Rescue&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_layrry_launcher&#34;&gt;The Layrry Launcher&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_using_the_layrry_api&#34;&gt;Using the Layrry API&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_next_steps&#34;&gt;Next Steps&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;One of the biggest changes in recent Java versions has been the introduction of the &lt;a href=&#34;http://openjdk.java.net/projects/jigsaw/spec/&#34;&gt;module system&lt;/a&gt; in Java 9.&#xA;It allows to organize Java applications and their dependencies in strongly encapsulated modules, utilizing explicit and well-defined module APIs and relationships.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In this post I’m going to introduce the &lt;a href=&#34;https://github.com/moditect/layrry&#34;&gt;Layrry&lt;/a&gt; open-source project, a launcher and Java API for executing modularized Java applications.&#xA;Layrry helps Java developers to assemble modularized applications from dependencies using their Maven coordinates and execute them using module layers.&#xA;Layers go beyond the capabilities of the &amp;#34;flat&amp;#34; module path specified via the &lt;em&gt;--module-path&lt;/em&gt; parameter of the &lt;em&gt;java&lt;/em&gt; command,&#xA;e.g. allowing to use multiple versions of one module within one and the same application.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
