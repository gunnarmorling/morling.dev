<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>simd on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/simd/</link>
    <description>Recent content in simd on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2019 - 2026 Gunnar Morling</copyright>
    <lastBuildDate>Mon, 08 Mar 2021 16:25:00 +0100</lastBuildDate>
    <atom:link href="https://www.morling.dev/tags/simd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FizzBuzz – SIMD Style!</title>
      <link>https://www.morling.dev/blog/fizzbuzz-simd-style/</link>
      <pubDate>Mon, 08 Mar 2021 16:25:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/fizzbuzz-simd-style/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_whats_simd_anyways&#34;&gt;What’s SIMD Anyways?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_vectorizing_fizzbuzz&#34;&gt;Vectorizing FizzBuzz&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_examining_the_native_code&#34;&gt;Examining the Native Code&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_avoiding_scalar_processing_of_tail_elements&#34;&gt;Avoiding Scalar Processing of Tail Elements&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_wrap_up&#34;&gt;Wrap-Up&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Java 16 is around the corner, so there’s no better time than now for learning more about the features which the new version will bring.&#xA;After exploring the support for &lt;a href=&#34;https://www.morling.dev/blog/talking-to-postgres-through-java-16-unix-domain-socket-channels/&#34;&gt;Unix domain sockets&lt;/a&gt; a while ago,&#xA;I’ve lately been really curious about the incubating Vector API,&#xA;as defined by &lt;a href=&#34;https://openjdk.java.net/jeps/338&#34;&gt;JEP 338&lt;/a&gt;,&#xA;developed under the umbrella of &lt;a href=&#34;https://openjdk.java.net/projects/panama/&#34;&gt;Project Panama&lt;/a&gt;,&#xA;which aims at &amp;#34;interconnecting JVM and native code&amp;#34;.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;&lt;em&gt;Vectors?!?&lt;/em&gt;&#xA;Of course this is not about renewing the ancient Java collection types like &lt;code&gt;java.util.Vector&lt;/code&gt;&#xA;(&amp;lt;insert some pun about this here&amp;gt;),&#xA;but rather about an API which lets Java developers take advantage of the vector calculation capabilities you can find in most CPUs these days.&#xA;Now I’m by no means an expert on low-level programming leveraging specific CPU instructions,&#xA;but exactly that’s why I hope to make the case with this post that the new Vector API makes these capabilities approachable to a wide audience of Java programmers.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
