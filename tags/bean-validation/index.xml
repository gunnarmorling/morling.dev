<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bean-validation on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/bean-validation/</link>
    <description>Recent content in bean-validation on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2019 - 2023 Gunnar Morling</copyright>
    <lastBuildDate>Mon, 20 Jan 2020 17:30:00 +0100</lastBuildDate>
    
	<atom:link href="https://www.morling.dev/tags/bean-validation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Enforcing Java Record Invariants With Bean Validation</title>
      <link>https://www.morling.dev/blog/enforcing-java-record-invariants-with-bean-validation/</link>
      <pubDate>Mon, 20 Jan 2020 17:30:00 +0100</pubDate>
      
      <guid>https://www.morling.dev/blog/enforcing-java-record-invariants-with-bean-validation/</guid>
      <description>Record types are one of the most awaited features in Java 14; they promise to &#34;provide a compact syntax for declaring classes which are transparent holders for shallowly immutable data&#34;. One example where records should be beneficial are data transfer objects (DTOs), as e.g. found in the remoting layer of enterprise applications. Typically, certain rules should be applied to the attributes of such DTO, e.g. in terms of allowed values. The goal of this blog post is to explore how such invariants can be enforced on record types, using annotation-based constraints as provided by the Bean Validation API.</description>
    </item>
    
  </channel>
</rss>