<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>replication on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/replication/</link>
    <description>Recent content in replication on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2019 - 2026 Gunnar Morling</copyright>
    <lastBuildDate>Tue, 05 Aug 2025 13:55:00 +0200</lastBuildDate>
    <atom:link href="https://www.morling.dev/tags/replication/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Postgres Replication Slots: Confirmed Flush LSN vs. Restart LSN</title>
      <link>https://www.morling.dev/blog/postgres-replication-slots-confirmed-flush-lsn-vs-restart-lsn/</link>
      <pubDate>Tue, 05 Aug 2025 13:55:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/postgres-replication-slots-confirmed-flush-lsn-vs-restart-lsn/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_confirmed_flush_sn_tracking_consumer_progress&#34;&gt;confirmed_flush_sn: Tracking Consumer Progress&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_restart_lsn_handling_concurrent_transactions&#34;&gt;restart_lsn: Handling Concurrent Transactions&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_mid_transaction_recovery&#34;&gt;Mid-Transaction Recovery&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_looking_forward_streaming_in_progress_transactions&#34;&gt;Looking Forward: Streaming In-Progress Transactions&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Replication slots in Postgres keep track of how far consumers have read a replication stream.&#xA;After a restart, consumers—​either Postgres read replicas or external tools for change data capture (CDC), like &lt;a href=&#34;https://debezium.io/&#34;&gt;Debezium&lt;/a&gt;—resume reading from the last confirmed log sequence number (LSN) of their replication slot. The slot prevents the database from disposing of required log segments, allowing safe resumption after downtime.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In this post, we are going to take a look at why Postgres replication slots don’t have one but two LSN-related attributes: &lt;code&gt;restart_lsn&lt;/code&gt; and &lt;code&gt;confirmed_flush_lsn&lt;/code&gt;.&#xA;Understanding the difference between the two is crucial for troubleshooting replication issues, optimizing WAL retention, and avoiding common pitfalls in production environments.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Mastering Postgres Replication Slots: Preventing WAL Bloat and Other Production Issues</title>
      <link>https://www.morling.dev/blog/mastering-postgres-replication-slots/</link>
      <pubDate>Tue, 08 Jul 2025 13:55:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/mastering-postgres-replication-slots/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_use_the_pgoutput_logical_decoding_output_plug_in&#34;&gt;Use the pgoutput Logical Decoding Output Plug-in&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_define_a_maximum_replication_slot_size&#34;&gt;Define a Maximum Replication Slot Size&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_enable_heartbeats&#34;&gt;Enable Heartbeats&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_use_table_level_publications&#34;&gt;Use Table-level Publications&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_use_column_and_row_filters&#34;&gt;Use Column and Row Filters&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_enable_fail_over_slots&#34;&gt;Enable Fail-Over Slots&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_consider_using_replica_identity_full&#34;&gt;Consider Using Replica Identity FULL&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_monitor_monitor_monitor&#34;&gt;Monitor, Monitor, Monitor!&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_drop_unused_replication_slots&#34;&gt;Drop Unused Replication Slots&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_summary&#34;&gt;Summary&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Over the last couple of years, I’ve helped dozens of users and organizations to build Change Data Capture (CDC) pipelines for their Postgres databases. A key concern in that process is setting up and managing replication slots, which are Postgres&amp;#39; mechanism for making sure that any segments of the write-ahead log (WAL) of the database are kept around until they have been processed by registered replication consumers.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;When not being careful, a replication slot may cause unduly large amounts of WAL segments to be retained by the database. This post describes best practices helping to prevent this and other issues, discussing aspects like heartbeats, replication slot failover, monitoring, the management of Postgres publications, and more. While this is primarily based on my experience of using replication slots via &lt;a href=&#34;https://debezium.io/documentation/reference/stable/connectors/postgresql.html&#34;&gt;Debezium’s Postgres connector&lt;/a&gt;, the principles are generally applicable and are worth considering also when using other CDC tools for Postgres based on logical replication.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
