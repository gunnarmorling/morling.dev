<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>virtual-threads on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/virtual-threads/</link>
    <description>Recent content in virtual-threads on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2019 - 2026 Gunnar Morling</copyright>
    <lastBuildDate>Thu, 17 Jul 2025 10:25:00 +0200</lastBuildDate>
    <atom:link href="https://www.morling.dev/tags/virtual-threads/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Converting Future to CompletableFuture With Java Virtual Threads</title>
      <link>https://www.morling.dev/blog/future-to-completablefuture-with-java-virtual-threads/</link>
      <pubDate>Thu, 17 Jul 2025 10:25:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/future-to-completablefuture-with-java-virtual-threads/</guid>
      <description>&lt;div class=&#34;paragraph teaser&#34;&gt;&#xA;&lt;p&gt;This post explores how virtual threads in Java 21+ provide an elegant solution for converting legacy &lt;code&gt;Future&lt;/code&gt; objects into &lt;code&gt;CompletableFuture&lt;/code&gt; instances.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Since Java 8, the &lt;a href=&#34;https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/CompletableFuture.html&#34;&gt;&lt;code&gt;CompletableFuture&lt;/code&gt;&lt;/a&gt; API provides a convenient way for performing asynchronous operations in a functional, composable way.&#xA;This makes it very simple to call some long-running methods—​for instance involving external I/O—​asynchronously and process each result as soon as it is available, without blocking on any threads:&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Loom and Thread Fairness</title>
      <link>https://www.morling.dev/blog/loom-and-thread-fairness/</link>
      <pubDate>Fri, 27 May 2022 09:20:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/loom-and-thread-fairness/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_project_loom&#34;&gt;Project Loom&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_scheduling&#34;&gt;Scheduling&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_discussion&#34;&gt;Discussion&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Project Loom (&lt;a href=&#34;https://openjdk.java.net/jeps/425&#34;&gt;JEP 425&lt;/a&gt;) is probably amongst the most awaited feature additions to Java ever;&#xA;its implementation of virtual threads (or &amp;#34;green threads&amp;#34;) promises developers the ability to create highly concurrent applications,&#xA;for instance with hundreds of thousands of open HTTP connections,&#xA;sticking to the well-known thread-per-request programming model,&#xA;without having to resort to less familiar and often more complex to use reactive approaches.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Having been in the workings for several years, Loom got merged into the mainline of OpenJDK &lt;a href=&#34;https://github.com/openjdk/jdk/commit/9583e3657e43cc1c6f2101a64534564db2a9bd84&#34;&gt;just recently&lt;/a&gt; and is available as a preview feature in the latest &lt;a href=&#34;https://jdk.java.net/19/&#34;&gt;Java 19 early access builds&lt;/a&gt;.&#xA;I.e. it’s the perfect time to get your hands onto virtual threads and explore the new feature.&#xA;In this post I’m going to share an interesting aspect I learned about thread scheduling fairness for CPU-bound workloads running on Loom.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
