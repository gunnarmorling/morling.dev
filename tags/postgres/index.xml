<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>postgres on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/postgres/</link>
    <description>Recent content in postgres on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2019 - 2025 Gunnar Morling</copyright>
    <lastBuildDate>Mon, 03 Nov 2025 18:02:00 +0100</lastBuildDate>
    <atom:link href="https://www.morling.dev/tags/postgres/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>&#34;You Don&#39;t Need Kafka, Just Use Postgres&#34; Considered Harmful</title>
      <link>https://www.morling.dev/blog/you-dont-need-kafka-just-use-postgres-considered-harmful/</link>
      <pubDate>Mon, 03 Nov 2025 18:02:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/you-dont-need-kafka-just-use-postgres-considered-harmful/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Looking to make it to the front page of HackerNews? Then writing a post arguing that &amp;#34;Postgres is enough&amp;#34;, or why &amp;#34;you don’t need Kafka at your scale&amp;#34; is a pretty failsafe way of achieving exactly that. No matter how often it has been discussed before, this topic is always doing well. And sure, what’s not to love about that? I mean, it has it all: Postgres, everybody’s most favorite RDBMS—​check! Keeping things lean and easy—​sure, count me in! A somewhat spicy take—​bring it on!&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Postgres Replication Slots: Confirmed Flush LSN vs. Restart LSN</title>
      <link>https://www.morling.dev/blog/postgres-replication-slots-confirmed-flush-lsn-vs-restart-lsn/</link>
      <pubDate>Tue, 05 Aug 2025 13:55:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/postgres-replication-slots-confirmed-flush-lsn-vs-restart-lsn/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_confirmed_flush_sn_tracking_consumer_progress&#34;&gt;confirmed_flush_sn: Tracking Consumer Progress&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_restart_lsn_handling_concurrent_transactions&#34;&gt;restart_lsn: Handling Concurrent Transactions&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_mid_transaction_recovery&#34;&gt;Mid-Transaction Recovery&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_looking_forward_streaming_in_progress_transactions&#34;&gt;Looking Forward: Streaming In-Progress Transactions&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Replication slots in Postgres keep track of how far consumers have read a replication stream.&#xA;After a restart, consumers—​either Postgres read replicas or external tools for change data capture (CDC), like &lt;a href=&#34;https://debezium.io/&#34;&gt;Debezium&lt;/a&gt;—resume reading from the last confirmed log sequence number (LSN) of their replication slot. The slot prevents the database from disposing of required log segments, allowing safe resumption after downtime.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In this post, we are going to take a look at why Postgres replication slots don’t have one but two LSN-related attributes: &lt;code&gt;restart_lsn&lt;/code&gt; and &lt;code&gt;confirmed_flush_lsn&lt;/code&gt;.&#xA;Understanding the difference between the two is crucial for troubleshooting replication issues, optimizing WAL retention, and avoiding common pitfalls in production environments.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Mastering Postgres Replication Slots: Preventing WAL Bloat and Other Production Issues</title>
      <link>https://www.morling.dev/blog/mastering-postgres-replication-slots/</link>
      <pubDate>Tue, 08 Jul 2025 13:55:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/mastering-postgres-replication-slots/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_use_the_pgoutput_logical_decoding_output_plug_in&#34;&gt;Use the pgoutput Logical Decoding Output Plug-in&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_define_a_maximum_replication_slot_size&#34;&gt;Define a Maximum Replication Slot Size&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_enable_heartbeats&#34;&gt;Enable Heartbeats&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_use_table_level_publications&#34;&gt;Use Table-level Publications&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_use_column_and_row_filters&#34;&gt;Use Column and Row Filters&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_enable_fail_over_slots&#34;&gt;Enable Fail-Over Slots&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_consider_using_replica_identity_full&#34;&gt;Consider Using Replica Identity FULL&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_monitor_monitor_monitor&#34;&gt;Monitor, Monitor, Monitor!&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_drop_unused_replication_slots&#34;&gt;Drop Unused Replication Slots&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_summary&#34;&gt;Summary&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Over the last couple of years, I’ve helped dozens of users and organizations to build Change Data Capture (CDC) pipelines for their Postgres databases. A key concern in that process is setting up and managing replication slots, which are Postgres&amp;#39; mechanism for making sure that any segments of the write-ahead log (WAL) of the database are kept around until they have been processed by registered replication consumers.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;When not being careful, a replication slot may cause unduly large amounts of WAL segments to be retained by the database. This post describes best practices helping to prevent this and other issues, discussing aspects like heartbeats, replication slot failover, monitoring, the management of Postgres publications, and more. While this is primarily based on my experience of using replication slots via &lt;a href=&#34;https://debezium.io/documentation/reference/stable/connectors/postgresql.html&#34;&gt;Debezium’s Postgres connector&lt;/a&gt;, the principles are generally applicable and are worth considering also when using other CDC tools for Postgres based on logical replication.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Backfilling Postgres TOAST Columns in Debezium Data Change Events</title>
      <link>https://www.morling.dev/blog/backfilling-postgres-toast-columns-debezium-change-events/</link>
      <pubDate>Mon, 26 May 2025 16:40:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/backfilling-postgres-toast-columns-debezium-change-events/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_debezium_reselect_postprocessor&#34;&gt;Debezium Reselect Postprocessor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_flink_datastream_api&#34;&gt;Flink DataStream API&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_flink_sql_with_over_aggregation&#34;&gt;Flink SQL With OVER Aggregation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_flink_process_table_functions&#34;&gt;Flink Process Table Functions&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_summary_and_discussion&#34;&gt;Summary and Discussion&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph teaser&#34;&gt;&#xA;&lt;p&gt;Postgres logical replication, while powerful for capturing real-time data changes, presents challenges with TOAST columns,&#xA;whose values can be absent from data change events in specific situations.&#xA;This post discusses how Debezium addresses this through its built-in reselect post processor,&#xA;then explores more robust solutions leveraging Apache Flink’s capabilities for stateful stream processing,&#xA;including Flink SQL and the brand-new process table functions (PTFs) in Flink 2.1.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Last Updated Columns With Postgres</title>
      <link>https://www.morling.dev/blog/last-updated-columns-with-postgres/</link>
      <pubDate>Tue, 20 Feb 2024 09:15:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/last-updated-columns-with-postgres/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In many applications it’s a requirement to keep track of when a record was created and updated the last time.&#xA;Often, this is implemented by having columns such as &lt;code&gt;created_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt; within each table.&#xA;To make things as simple as possible for application developers,&#xA;the database itself should take care of maintaining these values automatically when a record gets inserted or updated.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>The Insatiable Postgres Replication Slot</title>
      <link>https://www.morling.dev/blog/insatiable-postgres-replication-slot/</link>
      <pubDate>Wed, 30 Nov 2022 14:00:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/insatiable-postgres-replication-slot/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_observation&#34;&gt;The Observation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_solution&#34;&gt;The Solution&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_take_away&#34;&gt;Take Away&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;While working on a demo for processing change events from Postgres with Apache Flink,&#xA;I noticed an interesting phenomenon:&#xA;A Postgres database which I had set up for that demo on Amazon RDS, ran out of disk space.&#xA;The machine had a disk size of 200 GiB which was fully used up in the course of less than two weeks.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Now a common cause for this kind of issue are replication slots which are not advanced:&#xA;in that case, Postgres will hold on to all WAL segments after the latest log sequence number (&lt;a href=&#34;https://pgpedia.info/l/LSN-log-sequence-number.html&#34;&gt;LSN&lt;/a&gt;) which was confirmed for that slot.&#xA;Indeed I had set up a replication slot (via the &lt;a href=&#34;https://www.decodable.co/connectors/postgres-cdc&#34;&gt;Decodable CDC source connector for Postgres&lt;/a&gt;, which is based on &lt;a href=&#34;https://debezium.io&#34;&gt;Debezium&lt;/a&gt;).&#xA;I then had stopped that connector, causing the slot to become inactive.&#xA;The problem was though that I was really sure that there was no traffic in that database whatsoever!&#xA;What could cause a WAL growth of ~18 GB/day then?&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Talking to Postgres Through Java 16 Unix-Domain Socket Channels</title>
      <link>https://www.morling.dev/blog/talking-to-postgres-through-java-16-unix-domain-socket-channels/</link>
      <pubDate>Sun, 31 Jan 2021 20:25:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/talking-to-postgres-through-java-16-unix-domain-socket-channels/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_postgres_jdbc_driver&#34;&gt;The Postgres JDBC Driver&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_vert_x_postgres_client&#34;&gt;The Vert.x Postgres Client&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_other_use_cases&#34;&gt;Other Use Cases&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Reading a blog post about what’s &lt;a href=&#34;https://www.loicmathieu.fr/wordpress/en/informatique/java-16-quoi-de-neuf/&#34;&gt;coming up in JDK 16&lt;/a&gt; recently,&#xA;I learned that one of the new features is support for Unix domain sockets (&lt;a href=&#34;https://openjdk.java.net/jeps/380&#34;&gt;JEP 380&lt;/a&gt;).&#xA;Before Java 16, you’d have to resort to 3rd party libraries like &lt;a href=&#34;https://github.com/jnr/jnr-unixsocket&#34;&gt;jnr-unixsocket&lt;/a&gt; in order to use them.&#xA;If you haven’t heard about &lt;a href=&#34;https://en.wikipedia.org/wiki/Unix_domain_socket&#34;&gt;Unix domain sockets&lt;/a&gt; before,&#xA;they are &amp;#34;data communications [endpoints] for exchanging data between processes executing on the same host operating system&amp;#34;.&#xA;Don’t be put off by the name btw.;&#xA;Unix domain sockets are also supported by macOS and even Windows since &lt;a href=&#34;https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/&#34;&gt;version 10&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
