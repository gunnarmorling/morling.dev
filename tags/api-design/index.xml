<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>api-design on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/api-design/</link>
    <description>Recent content in api-design on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2019 - 2025 Gunnar Morling</copyright>
    <lastBuildDate>Wed, 12 Jan 2022 19:20:00 +0100</lastBuildDate>
    <atom:link href="https://www.morling.dev/tags/api-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>What&#39;s in a Good Error Message?</title>
      <link>https://www.morling.dev/blog/whats-in-a-good-error-message/</link>
      <pubDate>Wed, 12 Jan 2022 19:20:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/whats-in-a-good-error-message/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_context&#34;&gt;Context&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_error_itself&#34;&gt;The Error Itself&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_mitigation&#34;&gt;Mitigation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_general_best_practices&#34;&gt;General Best Practices&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;As software developers, we’ve all come across those annoying, not-so-useful error messages when using some library or framework: &lt;em&gt;&amp;#34;Couldn’t parse config file&amp;#34;&lt;/em&gt;, &lt;em&gt;&amp;#34;Lacking permission for this operation&amp;#34;&lt;/em&gt;, etc.&#xA;Ok, ok, so &lt;em&gt;something&lt;/em&gt; went wrong apparently; but what exactly? What config file? Which permissions? And what should you do about it?&#xA;Error messages lacking this kind of information quickly create a feeling of frustration and helplessness.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;So what makes a good error message then?&#xA;To me, it boils down to three pieces of information which should be conveyed by an error message:&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;ulist&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Context:&lt;/strong&gt; What led to the error? What was the code trying to do when it failed?&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;The error itself:&lt;/strong&gt; What exactly failed?&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Mitigation:&lt;/strong&gt; What needs to be done in order to overcome the error?&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Refining The Return Type Of Java Methods Without Breaking Backwards-Compatibility</title>
      <link>https://www.morling.dev/blog/refining-return-type-java-methods-without-breaking-backwards-compatibility/</link>
      <pubDate>Mon, 22 Nov 2021 18:30:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/refining-return-type-java-methods-without-breaking-backwards-compatibility/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_problem&#34;&gt;The Problem&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_bridge_methods_to_the_rescue&#34;&gt;Bridge Methods to the Rescue&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_creating_bridge_methods_ourselves&#34;&gt;Creating Bridge Methods Ourselves&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;If you work on any kind of software library,&#xA;ensuring backwards-compatibility is a key concern:&#xA;if there’s one thing which users really dislike, it is breaking changes in a new version of a library.&#xA;The rules of what can (and cannot) be changed in a Java API without breaking existing consumers are well defined in the Java language specification (JLS),&#xA;but things can get pretty interesting in certain corner cases.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The Eclipse team provides a &lt;a href=&#34;https://wiki.eclipse.org/Evolving_Java-based_APIs_2&#34;&gt;comprehensive overview&lt;/a&gt; about API evolution guidelines in their wiki.&#xA;When I shared the link to this great resource on Twitter the other day,&#xA;I received an &lt;a href=&#34;https://twitter.com/lukaseder/status/1462358911072317440&#34;&gt;interesting reply&lt;/a&gt; from Lukas Eder:&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;quoteblock&#34;&gt;&#xA;&lt;blockquote&gt;&#xA;I wish Java had a few tools to prevent some cases of binary compatibility breakages. E.g. when refining a method return type, I’d like to keep the old method around in byte code (but not in source code).&#xA;&lt;br/&gt;&#xA;&lt;br/&gt;&#xA;I think kotlin has such tools?&#xA;&lt;/blockquote&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;In the remainder of this post,&#xA;I’d like to provide some more insight into that problem mentioned by Lukas,&#xA;and how it can be addressed using an open-source tool called &lt;a href=&#34;https://github.com/dmlloyd/bridger&#34;&gt;Bridger&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>The Emitter Parameter Pattern for Flexible SPI Contracts</title>
      <link>https://www.morling.dev/blog/emitter-parameter-pattern-for-flexible-spis/</link>
      <pubDate>Mon, 04 May 2020 17:30:00 +0200</pubDate>
      <guid>https://www.morling.dev/blog/emitter-parameter-pattern-for-flexible-spis/</guid>
      <description>&lt;div id=&#34;toc&#34; class=&#34;toc&#34;&gt;&#xA;&lt;div id=&#34;toctitle&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul class=&#34;sectlevel1&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_an_example&#34;&gt;An Example&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#_the_emitter_parameter_pattern&#34;&gt;The Emitter Parameter Pattern&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;For libraries and frameworks it’s a common requirement to make specific aspects customizeable via &lt;a href=&#34;https://en.wikipedia.org/wiki/Service_provider_interface&#34;&gt;service provider interfaces&lt;/a&gt; (SPIs):&#xA;contracts to be implemented by the application developer, which then are invoked by framework code,&#xA;adding new or replacing existing functionality.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;Often times, the method implementations of such an SPI need to return value(s) to the framework.&#xA;An alternative to return values are &amp;#34;emitter parameters&amp;#34;:&#xA;passed by the framework to the SPI method, they offer an &lt;em&gt;API&lt;/em&gt; for receiving value(s) via method calls.&#xA;Certainly not revolutionary or even a new idea,&#xA;I find myself using emitter parameters more and more in libraries and frameworks I work on.&#xA;Hence I’d like to discuss some advantages I perceive about the emitter parameter pattern.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
