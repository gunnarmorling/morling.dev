<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>internals on Gunnar Morling</title>
    <link>https://www.morling.dev/tags/internals/</link>
    <description>Recent content in internals on Gunnar Morling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2019 - 2025 Gunnar Morling</copyright>
    <lastBuildDate>Sun, 20 Feb 2022 21:15:00 +0100</lastBuildDate>
    <atom:link href="https://www.morling.dev/tags/internals/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The JDK Flight Recorder File Format</title>
      <link>https://www.morling.dev/blog/jdk-flight-recorder-file-format/</link>
      <pubDate>Sun, 20 Feb 2022 21:15:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/jdk-flight-recorder-file-format/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://openjdk.java.net/jeps/328&#34;&gt;JDK Flight Recorder&lt;/a&gt; (JFR) is one of Java’s secret weapons;&#xA;deeply integrated into the Hotspot VM, it’s a high-performance event collection framework,&#xA;which lets you collect metrics on runtime aspects like object allocation and garbage collection,&#xA;class loading, file and network I/O, and lock contention, do method profiling, and much more.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;JFR data is persisted in recording files&#xA;(since Java 14, also &lt;a href=&#34;https://openjdk.java.net/jeps/349&#34;&gt;&amp;#34;realtime&amp;#34; event streaming&lt;/a&gt; is supported),&#xA;which can be loaded for analysis into tools like JDK Mission Control (JMC),&#xA;or the &lt;em&gt;jfr&lt;/em&gt; utility coming with OpenJDK itself.&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>The Anatomy of ct.sym — How javac Ensures Backwards Compatibility</title>
      <link>https://www.morling.dev/blog/the-anatomy-of-ct-sym-how-javac-ensures-backwards-compatibility/</link>
      <pubDate>Mon, 26 Apr 2021 18:45:00 +0100</pubDate>
      <guid>https://www.morling.dev/blog/the-anatomy-of-ct-sym-how-javac-ensures-backwards-compatibility/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;One of the ultimate strengths of Java is its strong notion of backwards compatibility:&#xA;Java applications and libraries built many years ago oftentimes run without problems on current JVMs,&#xA;and the compiler of current JDKs can produce byte code, that is executable with earlier Java versions.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;paragraph&#34;&gt;&#xA;&lt;p&gt;For instance, JDK 16 supports byte code levels going back as far as to Java 1.7;&#xA;But: &lt;em&gt;hic sunt dracones&lt;/em&gt;.&#xA;The emitted byte code level is just one part of the story.&#xA;It’s equally important to consider which APIs of the JDK are used by the compiled code,&#xA;and whether they are available in the targeted Java runtime version.&#xA;As an example, let’s consider this simple &amp;#34;Hello World&amp;#34; program:&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
