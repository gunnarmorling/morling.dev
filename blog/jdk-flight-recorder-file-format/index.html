<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>The JDK Flight Recorder File Format - Gunnar Morling</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="The JDK Flight Recorder File Format" />
<meta property="og:description" content="
The JDK Flight Recorder (JFR) is one of Java&#8217;s secret weapons;
deeply integrated into the Hotspot VM, it&#8217;s a high-performance event collection framework,
which lets you collect metrics on runtime aspects like object allocation and garbage collection,
class loading, file and network I/O, and lock contention, do method profiling, and much more.


JFR data is persisted in recording files
(since Java 14, also &#34;realtime&#34; event streaming is supported),
which can be loaded for analysis into tools like JDK Mission Control (JMC),
or the jfr utility coming with OpenJDK itself.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.morling.dev/blog/jdk-flight-recorder-file-format/" />
<meta property="article:published_time" content="2022-02-20T21:15:00+01:00" />
<meta property="article:modified_time" content="2022-02-20T21:15:00+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The JDK Flight Recorder File Format"/>
<meta name="twitter:description" content="
The JDK Flight Recorder (JFR) is one of Java&#8217;s secret weapons;
deeply integrated into the Hotspot VM, it&#8217;s a high-performance event collection framework,
which lets you collect metrics on runtime aspects like object allocation and garbage collection,
class loading, file and network I/O, and lock contention, do method profiling, and much more.


JFR data is persisted in recording files
(since Java 14, also &#34;realtime&#34; event streaming is supported),
which can be loaded for analysis into tools like JDK Mission Control (JMC),
or the jfr utility coming with OpenJDK itself.
"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet" />
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />
 
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.morling.dev/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.morling.dev/css/main.css" />

	
	<link rel="stylesheet" type="text/css" href="https://www.morling.dev/css/base16.dark.css" />
	
	<link rel="stylesheet" type="text/css" href="https://www.morling.dev/css/morlingdev.css" />
	

	<script>
		const searchUrl = "https:\/\/search.gunnar-morling.workers.dev\/Prod\/";
		const apiKey = "ff90d45f4afad3bd914c";
	</script>

	<script src="https://www.morling.dev//js/main.js"></script>
	<script src="https://www.morling.dev//js/medium-zoom.min.js"></script>

	<noscript>
		<style type="text/css">
			.club { display:none; }
		</style>
	</noscript>
</head>

<body>
	<div class="container wrapper post">
		<div class="header desktop">

	<div class="row">
		<div class="header-image-container">
			<img class="header-image" src="/images/gunnar_morling.jpg" alt="Gunnar Morling">
		</div>
		<div class="fill">
			<h1 class="site-title"><a href="https://www.morling.dev/">Gunnar Morling</a></h1>
			<div class="site-description"><h2>Random Musings on All Things Software Engineering</h2></div>

			<nav class="row pre-nav">
				<div class="pull-right">
					<ul class="flat"><li>
							<a href="/blog/index.xml" title="RSS FEED">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#rss"/>
								</svg>
							</a>
						</li><li>
							<a href="https://github.com/gunnarmorling" title="GitHub">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#github"/>
								</svg>
							</a>
						</li><li>
							<a href="https://twitter.com/gunnarmorling" title="Twitter">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#twitter"/>
								</svg>
							</a>
						</li></ul>
				</div>
			</nav>
			<nav class="row nav">
				<div>
					<ul class="flat">
						
						<li>
							<a href="/">Blog</a>
						</li>
						
						<li>
							<a href="/projects/">Projects</a>
						</li>
						
						<li>
							<a href="/conferences/">Conferences</a>
						</li>
						
						<li>
							<a href="/podcasts/">Podcasts</a>
						</li>
						
						<li>
							<a href="/about/">About</a>
						</li>
						
					</ul>
				</div>
				<div class="pull-right">
					<div class="club">
						<form id="myForm">
							<input type="text" id="inputSearch" name="q" placeholder="Search..." onfocus="warmUp(this)">
							<button type="submit" id="buttonSubmitSearch" style="line-height: normal;"><i id="iconSearch" class="fa fa-search"></i></button>
						</form>
					</div>
				</div>
			</nav>
		</div>
	</div>
</div>

<div class="header mobile">

	<div class="row">
		<div class="header-image-container">
			<img class="header-image" src="/images/gunnar_morling.jpg" alt="Gunnar Morling">
		</div>
		<div class="fill">
			<h1 class="site-title"><a href="https://www.morling.dev/">Gunnar Morling</a></h1>
			<div class="site-description"><h2>Random Musings on All Things Software Engineering</h2></div>
		</div>
	</div>
	<div>
		<div>
			<nav class="row pre-nav">
				<div class="pull-right">
					<ul class="flat"><li>
							<a href="/blog/index.xml" title="RSS FEED">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#rss"/>
								</svg>
							</a>
						</li><li>
							<a href="https://github.com/gunnarmorling" title="GitHub">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#github"/>
								</svg>
							</a>
						</li><li>
							<a href="https://twitter.com/gunnarmorling" title="Twitter">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#twitter"/>
								</svg>
							</a>
						</li></ul>
				</div>
			</nav>
			<nav class="row nav">
				<div>
					<ul class="flat">
						
						<li>
							<a href="/">Blog</a>
						</li>
						
						<li>
							<a href="/projects/">Projects</a>
						</li>
						
						<li>
							<a href="/conferences/">Conferences</a>
						</li>
						
						<li>
							<a href="/podcasts/">Podcasts</a>
						</li>
						
						<li>
							<a href="/about/">About</a>
						</li>
						
					</ul>
				</div>
				<div class="pull-right">
					<div class="club">
						<form id="myFormMobile">
							<input type="text" id="inputSearchMobile" name="q" placeholder="Search..." onfocus="warmUp(this)">
							<button type="submit" id="buttonSubmitSearchMobile" style="line-height: normal;"><i id="iconSearchMobile" class="fa fa-search"></i></button>
						</form>
					</div>
				</div>
			</nav>
		</div>
	</div>
</div>

<script type="text/javascript">
	window.addEventListener( "load", function () {
		const urlParams = new URLSearchParams(window.location.search);

		


		const form = document.getElementById( "myForm" );

		form.addEventListener("submit", function (event) {
			event.preventDefault();
			sendData(new FormData(form));
		});

		const formMobile = document.getElementById( "myFormMobile" );

		formMobile.addEventListener("submit", function (event) {
			event.preventDefault();
			sendData(new FormData(formMobile));
		});
	});
</script>


		<div id = "main-content">
			<div class="post-header">
				<h1 class="title">The JDK Flight Recorder File Format</h1>
				<div class="meta">Posted at Feb 20, 2022</div>
			</div>

			<div class="markdown">
				<div class="paragraph">
<p>The <a href="https://openjdk.java.net/jeps/328">JDK Flight Recorder</a> (JFR) is one of Java&#8217;s secret weapons;
deeply integrated into the Hotspot VM, it&#8217;s a high-performance event collection framework,
which lets you collect metrics on runtime aspects like object allocation and garbage collection,
class loading, file and network I/O, and lock contention, do method profiling, and much more.</p>
</div>
<div class="paragraph">
<p>JFR data is persisted in recording files
(since Java 14, also <a href="https://openjdk.java.net/jeps/349">"realtime" event streaming</a> is supported),
which can be loaded for analysis into tools like JDK Mission Control (JMC),
or the <em>jfr</em> utility coming with OpenJDK itself.</p>
</div>
<div class="paragraph">
<p>While there&#8217;s lots of blog posts, conference talks, and other coverage on JFR itself,
information about the format of recording files is surprisingly heard to come by.
There is no official specification,
so the only way to actually understand the JFR file format is to read the source code for writing recordings in the JDK itself,
which is a combination of <a href="https://github.com/openjdk/jdk/tree/master/src/jdk.jfr/share/classes/jdk/jfr/internal">Java</a> and <a href="https://github.com/openjdk/jdk/tree/jdk-17%2B35/src/hotspot/share/jfr/recorder">C++ code</a>.
Alternatively, you can study the code for <a href="https://github.com/openjdk/jmc/tree/master/core/org.openjdk.jmc.flightrecorder">parsing recordings</a> in JMC (an official JDK project).
Btw., JMC comes with a pure Java-based JFR file <a href="https://github.com/openjdk/jmc/tree/master/core/org.openjdk.jmc.flightrecorder.writer">writer implementation</a> too.</p>
</div>
<div class="paragraph">
<p>Apart from the source code itself,
the only somewhat related resources which I could find are this <a href="https://www.slideshare.net/stalar/con5091-larsen-jfr">JavaOne presentation</a> by Staffan Larssan (2013, still referring to the proprietary Oracle JFR),
several <a href="http://hirt.se/blog/?tag=jfr">JFR-related blog posts</a> by Marcus Hirt,
and a post <a href="https://richardstartin.github.io/posts/jfr-event-sizes">about JFR event sizes</a> by Richard Startin.
But there&#8217;s no in-depth discussion or explanation of the file format.
As it turns out, this by design;
the OpenJDK team shied away <a href="https://twitter.com/ErikGahlin/status/1495338682651402242">from creating a spec</a>,
"because of the overhead of maintaining and staying compatible with it".
I.e. the JFR file format is an implementation detail of OpenJDK,
and as such the only stable contract for interacting with it are the APIs provided by JFR.</p>
</div>
<div class="paragraph">
<p>Now, also if it is an implementation detail, knowing more about the JFR file format would certainly be useful;
for instance, you could use this to implement tools for analyzing and visualizing JFR data in non-JVM programming languages,
say Python, or to patch corrupted recording files.
So my curiosity was piqued and I thought it&#8217;d be fun to try and find out how JFR recording files are structured.
In particular, I was curious about which techniques are used for keeping files relatively small,
also with hundreds of thousands or even millions of recoreded events.</p>
</div>
<div class="paragraph">
<p>I grabbed a hex editor, the source code of JMC&#8217;s recording parser
(which I found a bit easier to grasp than the Java/C++ hybrid in the JDK itself),
and loaded several example recordings from my <a href="https://github.com/moditect/jfr-analytics">JFR Analytics</a> project,
stepping through the parser code in debug mode
(fun fact: while doing so, I noticed JMC currently fails to parse events with <a href="https://github.com/openjdk/jmc/pull/378"><code>char</code> attributes</a>).</p>
</div>
<div class="paragraph">
<p>Just a feeew hours later, and I largely understood how the thing works.
As an image says more than a thousand words,
and I&#8217;ll never say no to an opportunity to draw something in the fabuluous <a href="https://excalidraw.com/">Excalidraw</a>,
so I proudly present to you this visualization of the JFR file format as per my understanding
(click to enlarge):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/images/jfr_file_format.png" alt="jfr file format">
</div>
</div>
<div class="paragraph">
<p>It&#8217;s best viewed on a big screen ðŸ˜Ž.
Alternatively, here&#8217;s a <a href="/images/jfr_file_format.svg" target="_blank" rel="noopener">SVG version</a>.
Now this doesn&#8217;t go into all the finest aspects,
so you probably couldn&#8217;t go off and implement a clean-room JFR file parser solely based on this.
But it does show the relevant concepts and mechanisms.
I suggest you spend some time going through sections one to five in the picture,
and dive into the sections for header, metadata, constant pool, and actual recorded events.
Studying the image should give you a good understanding of the JFR file format and its structure.</p>
</div>
<div class="paragraph">
<p>Here are some observations I made as I found my way through the file format:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>JFR recordings are organized in chunks:</em> Chunks are self-contained independent containers of recorded events and all the metadata required for interpreting these events.
There&#8217;s no additional content in recordings besides the chunks, i.e. <a href="https://twitter.com/BriceDutheil/status/1495506834387619847">concat several chunk files</a>, and you&#8217;ll have a JFR recording file.
A multi-chunk recording file can be split up into the individual chunks using the <a href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/jfr.html"><em>jfr</em></a> utility which comes with OpenJDK:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre>jfr disassemble --output <span class="nt">&lt;target-dir&gt;</span> some-recording.jfr
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The default chunksize is 12MB, but if needed, you can override this, e.g. using the <code>-XX:FlightRecorderOptions:maxchunksize=1MB</code> option when starting a recording.
A smaller chunk size can come in handy if for instance you only want to transmit a specific section of a long-running recording.
On the other hand, many small chunks will increase the overall size of a recording,
due to the repeatedly stored metadata and constant pools</p>
</div>
</li>
<li>
<p><em>The event format is self-descriptive:</em> The metadata part of each chunk describes the structure of the contained events, all referenced types, their attributes, etc.; by means of JFR <a href="https://docs.oracle.com/en/java/javase/17/docs/api/jdk.jfr/jdk/jfr/MetadataDefinition.html">metadata annotations</a>, such as <code>@Label</code>, <code>@Description</code>, <code>@Timestamp</code> etc., further metadata like human-readable names and description as well as units of measurements are expressed,
allowing to consume and parse an event stream without a-priori knowledge of specific event types. In particular, this allows for the definition of <a href="/blog/rest-api-monitoring-with-custom-jdk-flight-recorder-events/">custom event types</a> and displaying them in the generic event browser of JMC (of course, bespoke views such as the "Memory" view rely on type-specific interpretations of individual event types)</p>
</li>
<li>
<p><em>The format is geared towards space efficiency:</em> Integer values are stored in a variable-length encoded way (<a href="https://en.wikipedia.org/wiki/LEB128">LEB128</a>), which will safe lots of space when storing small values.
A constant pool is used to store repeatedly referenced objects, such as String literals,
stack traces, class and method names, etc.;
for each usage of such constant in a recorded event, only the constant pool index is stored
(a var-length encoded <code>long</code>).
Note that Strings can either be stored as raw values within events themselves, or in the constant pool. Unfortunately, no control is provided for choosing between the two; strings with a length between 16 and 128 will be stored in the constant pool, any others as raw value. It could be a nice extension to give event authors more control here, e.g. by means of an annotation on the event attribute definition</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the <code>jdk.OldObjectSample</code> event type,
beware of bug <a href="https://bugs.openjdk.java.net/browse/JDK-8277919">JDK-8277919</a>,
which may cause a bloat of the constant pool,
as the same entry is duplicated in the pool many times.
This will be fixed in Java 17.0.3 and 18.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><em>The format is row-based:</em> Events are stored sequentially one after another in recording files; this means that for instance boolean attributes will consume one full byte, also if actually eight boolean values could be stored in a single byte.
It could be interesting to explore a columnar format as an alternative,
which may help to further reduce recording size,
for instance also allowing to efficiently compress event timestamps values using <a href="https://en.wikipedia.org/wiki/Delta_encoding">delta-encoding</a></p>
</li>
<li>
<p><em>Compression support in JMC reader implementation:</em> The JFR parser implementation of JMC transparently unpacks recording files which are compressed using GZip, ZIP, or LZ4
(Marcus Hirt discusses the compression of JFR recordings in <a href="http://hirt.se/blog/?p=1166">this post</a>).
Interestingly, JMC 8.1 still failed to open such compressed recording with an error message.
The <em>jfr</em> utility doesn&#8217;t support compressed recording files, and I suppose the JFR writer in the JDK doesn&#8217;t produce compressed recordings either</p>
</li>
</ul>
</div>
			</div>

			<div class="post-tags">
				
					
				
			</div>
		</div><div id="disqus_thread">
  <script src="https://giscus.app/client.js"
    data-repo="gunnarmorling/discussions.morling.dev"
    data-repo-id="R_kgDOGXzqNQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOGXzqNc4B_2Pq"
    data-mapping="title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
  </script>
</div>

<noscript>Please enable JavaScript, or join the <a href="https://github.com/gunnarmorling/discussions.morling.dev/discussions/">discussion on GitHub</a>.</noscript>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> Â© 2021 Gunnar Morling |  Licensed Under <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons BY-SA 4.0</a></div>
	</nav>
</div>


<script type="application/javascript">
var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
var doNotTrack = (dnt == "1" || dnt == "yes");
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	if (window.sessionStorage) {
		var GA_SESSION_STORAGE_KEY = 'ga:clientId';
		ga('create', 'UA-156032495-1', {
	    'storage': 'none',
	    'clientId': sessionStorage.getItem(GA_SESSION_STORAGE_KEY)
	   });
	   ga(function(tracker) {
	    sessionStorage.setItem(GA_SESSION_STORAGE_KEY, tracker.get('clientId'));
	   });
   }
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script>
	mediumZoom(document.querySelectorAll('div.imageblock > div.content > img'))
</script>

</body>
</html>
