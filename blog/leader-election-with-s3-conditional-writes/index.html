<!DOCTYPE html>
<html>
<head>
	
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DD997656SV"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'G-DD997656SV');
	</script>

	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Leader Election With S3 Conditional Writes - Gunnar Morling</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Leader Election With S3 Conditional Writes" />
<meta property="og:description" content="
Update Aug 30: This article is discussed on Hacker News and lobste.rs.


In distributed systems, for instance when scaling out some workload to multiple compute nodes,
it is a common requirement to select a leader for performing a given task:
only one of the nodes should process the records from a Kafka topic partition, write to a file system, call a remote API, etc.
Otherwise, multiple workers may end up doing the same task twice, overwriting each other’s data, and worse.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.morling.dev/blog/leader-election-with-s3-conditional-writes/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2024-08-26T09:15:00+01:00" />
<meta property="article:modified_time" content="2024-08-26T09:15:00+01:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Leader Election With S3 Conditional Writes"/>
<meta name="twitter:description" content="
Update Aug 30: This article is discussed on Hacker News and lobste.rs.


In distributed systems, for instance when scaling out some workload to multiple compute nodes,
it is a common requirement to select a leader for performing a given task:
only one of the nodes should process the records from a Kafka topic partition, write to a file system, call a remote API, etc.
Otherwise, multiple workers may end up doing the same task twice, overwriting each other’s data, and worse.
"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet" />
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />
 
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.morling.dev/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://www.morling.dev/css/main.css" />

	
	<link rel="stylesheet" type="text/css" href="https://www.morling.dev/css/base16.dark.css" />
	
	<link rel="stylesheet" type="text/css" href="https://www.morling.dev/css/morlingdev.css" />
	

	<script>
		const searchUrl = "https:\/\/search-morling-dev.onrender.com\/";
		const apiKey = "ff90d45f4afad3bd914c";
	</script>

	<script src="https://www.morling.dev//js/main.js"></script>
	<script src="https://www.morling.dev//js/medium-zoom.min.js"></script>

	<noscript>
		<style type="text/css">
			.club { display:none; }
		</style>
	</noscript>
</head>

<body>
	<div class="container wrapper post">
		<div class="header desktop">

	<div class="row">
		<div class="header-image-container">
			<img class="header-image" src="/images/gunnar_morling.jpg" alt="Gunnar Morling">
		</div>
		<div class="fill">
			<h1 class="site-title"><a href="https://www.morling.dev/">Gunnar Morling</a></h1>
			<div class="site-description"><h2>Random Musings on All Things Software Engineering</h2></div>

			<nav class="row pre-nav">
				<div class="pull-right">
					<ul class="flat"><li>
							<a href="/blog/index.xml" title="RSS FEED">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#rss"/>
								</svg>
							</a>
						</li><li>
							<a href="https://github.com/gunnarmorling" title="GitHub">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#github"/>
								</svg>
							</a>
						</li><li>
							<a href="https://twitter.com/gunnarmorling" title="Twitter">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#twitter"/>
								</svg>
							</a>
						</li><li>
							<a href="https://www.linkedin.com/in/gunnar-morling-2b44b7229/" title="LinkedIn">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#linkedin"/>
								</svg>
							</a>
						</li><li>
							<a href="https://mastodon.online/@gunnarmorling" title="Mastodon">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#message-square"/>
								</svg>
							</a>
						</li></ul>
				</div>
			</nav>
			<nav class="row nav">
				<div>
					<ul class="flat">
						
						<li>
							<a href="/">Blog</a>
						</li>
						
						<li>
							<a href="/projects/">Projects</a>
						</li>
						
						<li>
							<a href="/conferences/">Conferences</a>
						</li>
						
						<li>
							<a href="/podcasts/">Podcasts</a>
						</li>
						
						<li>
							<a href="/about/">About</a>
						</li>
						
					</ul>
				</div>
				<div class="pull-right">
					<div class="club">
						<form id="myForm">
							<input type="text" id="inputSearch" name="q" placeholder="Search..." onfocus="warmUp(this)">
							<button type="submit" id="buttonSubmitSearch" style="line-height: normal;"><i id="iconSearch" class="fa fa-search"></i></button>
						</form>
					</div>
				</div>
			</nav>
		</div>
	</div>
</div>

<div class="header mobile">

	<div class="row">
		<div class="header-image-container">
			<img class="header-image" src="/images/gunnar_morling.jpg" alt="Gunnar Morling">
		</div>
		<div class="fill">
			<h1 class="site-title"><a href="https://www.morling.dev/">Gunnar Morling</a></h1>
			<div class="site-description"><h2>Random Musings on All Things Software Engineering</h2></div>
		</div>
	</div>
	<div>
		<div>
			<nav class="row pre-nav">
				<div class="pull-right">
					<ul class="flat"><li>
							<a href="/blog/index.xml" title="RSS FEED">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#rss"/>
								</svg>
							</a>
						</li><li>
							<a href="https://github.com/gunnarmorling" title="GitHub">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#github"/>
								</svg>
							</a>
						</li><li>
							<a href="https://twitter.com/gunnarmorling" title="Twitter">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#twitter"/>
								</svg>
							</a>
						</li><li>
							<a href="https://www.linkedin.com/in/gunnar-morling-2b44b7229/" title="LinkedIn">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#linkedin"/>
								</svg>
							</a>
						</li><li>
							<a href="https://mastodon.online/@gunnarmorling" title="Mastodon">
								<svg width="17" height="17" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
									<use xlink:href="/svg/feather-sprite.svg#message-square"/>
								</svg>
							</a>
						</li></ul>
				</div>
			</nav>
			<nav class="row nav">
				<div>
					<ul class="flat">
						
						<li>
							<a href="/">Blog</a>
						</li>
						
						<li>
							<a href="/projects/">Projects</a>
						</li>
						
						<li>
							<a href="/conferences/">Conferences</a>
						</li>
						
						<li>
							<a href="/podcasts/">Podcasts</a>
						</li>
						
						<li>
							<a href="/about/">About</a>
						</li>
						
					</ul>
				</div>
				<div class="pull-right">
					<div class="club">
						<form id="myFormMobile">
							<input type="text" id="inputSearchMobile" name="q" placeholder="Search..." onfocus="warmUp(this)">
							<button type="submit" id="buttonSubmitSearchMobile" style="line-height: normal;"><i id="iconSearchMobile" class="fa fa-search"></i></button>
						</form>
					</div>
				</div>
			</nav>
		</div>
	</div>
</div>

<script type="text/javascript">
	window.addEventListener( "load", function () {
		const urlParams = new URLSearchParams(window.location.search);

		


		const form = document.getElementById( "myForm" );

		form.addEventListener("submit", function (event) {
			event.preventDefault();
			sendData(new FormData(form));
		});

		const formMobile = document.getElementById( "myFormMobile" );

		formMobile.addEventListener("submit", function (event) {
			event.preventDefault();
			sendData(new FormData(formMobile));
		});
	});
</script>


		<div id = "main-content">
			<div class="post-header">
				<h1 class="title">Leader Election With S3 Conditional Writes</h1>
				<div class="meta">Posted at Aug 26, 2024</div>
			</div>

			<div class="markdown">
				<div class="paragraph">
<p><em>Update Aug 30: This article is discussed on <a href="https://news.ycombinator.com/item?id=41357123">Hacker News</a> and <a href="https://lobste.rs/s/ljq5pm/leader_election_with_s3_conditional">lobste.rs</a>.</em></p>
</div>
<div class="paragraph">
<p>In distributed systems, for instance when scaling out some workload to multiple compute nodes,
it is a common requirement to select a <em>leader</em> for performing a given task:
only one of the nodes should process the records from a Kafka topic partition, write to a file system, call a remote API, etc.
Otherwise, multiple workers may end up doing the same task twice, overwriting each other’s data, and worse.</p>
</div>
<div class="paragraph">
<p>One way to implement <a href="https://aws.amazon.com/builders-library/leader-election-in-distributed-systems/">leader election</a> is distributed locking.
All the nodes compete to obtain a specific lock, but only one of them can succeed, which will then be the selected leader for as long as it holds that lock.
Systems like <a href="https://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_Locks">Apache ZooKeeper</a> or Postgres (via <a href="https://jeremydmiller.com/2020/05/05/using-postgresql-advisory-locks-for-leader-election/">Advisory Locks</a>) provide the required building blocks for this.</p>
</div>
<div class="paragraph">
<p>Now, if your application solely is in the business of writing data to object storage such as Amazon S3, Google Cloud Storage, or Azure Blob Storage, running such a stateful service solely for the purposes for leader election can be an overhead which you’d like to avoid from an operational as well as financial perspective.
While you could implement distributed locks on the latter two platforms for quite a while with their respective compare-and-swap (CAS) operations,
this <a href="https://materializedview.io/p/s3-is-showing-its-age">notoriously was not the case for S3</a>.
That is, until last week, when <a href="https://aws.amazon.com/about-aws/whats-new/2024/08/amazon-s3-conditional-writes/">AWS announced support</a> for conditional writes on S3,
which was received with great excitement by many folks in the data and distributed systems communities.</p>
</div>
<div class="paragraph">
<p>In a nutshell, the S3 <code>PutObject</code> operation now supports an optional <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-requests.html#conditional-writes"><code>If-None-Match</code> header</a>.
When specified, the call will only succeed when no file with the same key exists in the target bucket yet;
otherwise you’ll get a <code>412 Precondition Failed</code> response.
Compared to what’s available on GCP and Azure, that’s rather limited, but it’s all you need for implementing a locking scheme for leader election.</p>
</div>
<div class="sect1">
<h2 id="_the_algorithm">The Algorithm</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The basic idea is to have nodes compete on creating a lock file,
with the winner being the leader.
As S3 conditional writes don’t prevent lost updates to existing files,
a new lock file will be created for each leader <em>epoch</em>,
i.e. when leadership changes either after a node failure or when the leader releases the lock voluntarily.
The lock file can be a simple JSON structure like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">&#34;expired&#34;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>expired</code> attribute is used for releasing a lock after use (more on that below).
The leader epoch, a strictly increasing numeric value, is part of the file name, e.g. <em>lock_0000000001.json</em>.
This allows you to determine the current epoch by listing all lock files and finding the one with the highest epoch value
(all lock files but the latest one can be removed by a background process,
thus keeping the cost for the listing call constant).</p>
</div>
<div class="paragraph">
<p>Here’s the overall leader election algorithm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>1. List all lock files
2. If there is no lock file, or the latest one has expired:
   3. Increment the epoch value by 1 and try to create a new lock file
   4. If the lock file could be created:
      5. The current node is the leader, start with the actual work
   6. Otherwise, go back to 1.
7. Otherwise, another process already is the leader, so do nothing.
   Go back to 1. periodically</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_obtaining_the_lock">Obtaining the Lock</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To obtain the lock (step 3.), put a file for the next epoch.
The key thing is to pass the <code>If-None-Match</code> header and handle the potential <code>412 Precondition failed</code> response.
Using the AWS Java SDK, this could look like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="n">epoch</span> <span class="o">=</span> <span class="o">...;</span>

<span class="nc">PutObjectRequest</span> <span class="n">put</span> <span class="o">=</span> <span class="nc">PutObjectRequest</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">bucket</span><span class="o">(</span><span class="no">BUCKET</span><span class="o">)</span>
  <span class="o">.</span><span class="na">key</span><span class="o">(</span><span class="s">&#34;lock-%010d.json&#34;</span><span class="o">.</span><span class="na">formatted</span><span class="o">(</span><span class="n">epoch</span><span class="o">))</span>
  <span class="o">.</span><span class="na">ifNoneMatch</span><span class="o">(</span><span class="s">&#34;*&#34;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="k">try</span> <span class="o">{</span>
  <span class="n">s3</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">put</span><span class="o">,</span> <span class="nc">RequestBody</span><span class="o">.</span><span class="na">fromString</span><span class="o">(</span><span class="sh">&#34;&#34;&#34;
      {
        &#34;expired&#34;: false
      }
      &#34;&#34;&#34;</span><span class="o">));</span>
<span class="o">}</span>
<span class="k">catch</span><span class="o">(</span><span class="nc">S3Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">==</span> <span class="mi">412</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//handle elsewhere and start over</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">LockingFailedException</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you receive a 412 response, this means another process created the lock file since between you’ve listed the existing locks and now.
That way, it is guaranteed that only one process succeeds to create the lock for the current epoch and thus becomes the leader.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_expiring_a_lock">Expiring a Lock</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At some point, the current leader may decide to step down from this role,
for instance when gracefully shutting down.
This is as simple as setting the <code>expired</code> attribute to <code>true</code> and update the current lock file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">&#34;expired&#34;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>When other nodes list the existing lock files subsequently,
they’ll see that the lock has expired and thus a new leader needs to be elected.
Note that only ever that process which created the lock file for a given epoch may expire it,
otherwise chaos may ensue.
Naturally, this brings up the question of what happens when a leader never expires its lock,
such as when it crashes.
In that case, no new leader could ever be elected without manual intervention,
hampering the liveness of the system.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lock_validity">Lock Validity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To address this situation, you can add another attribute to the lock file format,
defining for how long it should be valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="json"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">&#34;validity_ms&#34;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">60000</span><span class="p">,</span><span class="w">
  </span><span class="nl">&#34;expired&#34;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the lock should be valid for 60 seconds.
For each file, S3 provides the last modification timestamp, specifying when it has been created or updated.
When performing its work, the current leader needs to check whether the lock is still valid
(i.e. have less than 60 seconds passed since the lock was obtained),
optionally touching the file in order to extend the lease.
Similarly, current non-leader nodes can check whether the latest lock is still valid or not.</p>
</div>
<div class="paragraph">
<p>What about clock drift though?
After all, you never should rely on clock accuracy of different nodes when building distributed systems.
But the good news is, you don’t have to.
Let’s discuss the different options.
If the current leader’s clock is ahead, it will stop doing its work, despite the lock still being valid.
Similarly, if the clock of a current non-leader is behind, it may not try to acquire leadership although the current lock already has expired.
While this may impact throughput of the system, both cases are not a correctness problem.</p>
</div>
<div class="paragraph">
<p>Things look different if the current leader relies on a lock after it has expired (because its clock is behind) and another leader has been elected already,
or if a non-leader determines prematurely that the current lock has expired (because its clock is ahead) and thus picks up leadership.</p>
</div>
<div class="paragraph">
<p>In both cases, there’s more than one node which assumes to be the leader, which is exactly what we want to avoid with leadership election.
But as it turns out, this is just the nature of the beast:
leader election <a href="https://ocheselandrei.github.io/2022/06/01/leader-election-vs-consensus.html">will only ever be eventually correct</a>.
As Martin Kleppmann describes in <a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">this excellent post</a>, checking lock validity and performing the leader’s actual work is not atomic,
no matter how hard you try (for instance, think of unexpected GC pauses).
So you’ll always need to be prepared to detect and fence off work done by a previous leader.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Minimizing Clock Drift</div>
<div class="paragraph">
<p>While you never should rely on clock consistency across systems from a correctness point of view,
it does make sense to keep clocks synchronous on a best-effort basis,
thus reducing the aforementioned throughput impact.
To do so, nodes could create a temporary file on S3 and compare its creation time on S3 with their local time.
Alternatively, you could use the Amazon Time Sync Service, which <a href="https://aws.amazon.com/about-aws/whats-new/2023/11/amazon-time-sync-service-microsecond-accurate-time/">offers micro-second time accuracy</a>.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fencing_off_zombies">Fencing Off Zombies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As a solution, Kleppmann suggests using the leader epoch as a fencing token.
The epoch value only ever increases, so it can be used to identify requests by a stale leader (&#34;zombie&#34;).
When for instance invoking a remote API, the fencing token could be passed as a request header,
allowing the API provider to recognize and discard zombie requests by keeping track of the highest epoch value it has seen.
Of course this requires the remote API to support the notion of fencing tokens,
which may or may not be the case.</p>
</div>
<div class="paragraph">
<p>As an example targeting S3 (which doesn’t have bespoke support for fencing tokens), <a href="https://github.com/slatedb/slatedb">SlateDB</a> implements this by <a href="https://github.com/slatedb/slatedb/blob/main/rfcs/0001-manifest.md">uploading files following a serial order</a> (similar to the lock file naming scheme above) and detecting conflicts between competing writers trying to create the same file.
Thanks to the new support for conditional writes on S3,
this task is trivial,
not requiring any external stateful services any longer.</p>
</div>
</div>
</div>
			</div>

			<div class="post-tags">
				
					
				
			</div>
		</div><div id="disqus_thread">
  <script src="https://giscus.app/client.js"
    data-repo="gunnarmorling/discussions.morling.dev"
    data-repo-id="R_kgDOGXzqNQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOGXzqNc4B_2Pq"
    data-mapping="title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
  </script>
</div>

<noscript>Please enable JavaScript, or join the <a href="https://github.com/gunnarmorling/discussions.morling.dev/discussions/">discussion on GitHub</a>.</noscript>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © 2019 - 2024 Gunnar Morling |  Licensed Under <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons BY-SA 4.0</a></div>
	</nav>
</div><script>
	mediumZoom(document.querySelectorAll('div.imageblock > div.content > img'))
</script>

</body>
</html>
